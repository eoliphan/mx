// Generated by CoffeeScript 1.6.1
(function() {
  var Artist, ObjectId, Offer, Order, Revenue, Wager, logger, mongoose, _;

  logger = require('../logger');

  Order = require('../repositories/order').Order;

  Wager = require('../repositories/wager').Wager;

  Offer = require('../repositories/offer').Offer;

  Revenue = require('../repositories/offer').Revenue;

  Artist = require('../repositories/artist').Artist;

  mongoose = require('mongoose');

  _ = require('underscore');

  ObjectId = mongoose.Types.ObjectId;

  exports.orderBought = function(event) {
    logger.debug(event);
    return Order.findOne({
      sessionId: event.payload.sessionId
    }, function(err, order) {
      var nextSessOrd;
      order.type = 'order';
      order.sessOrd = parseInt(order.sessOrd) + 1;
      nextSessOrd = order.sessOrd + 1;
      _.each(order.items, function(item, index, list) {
        var itemId, orderDate, price;
        itemId = item.itemId;
        price = item.price;
        orderDate;
        if (!event.payload.orderDate) {
          orderDate = new Date();
        } else {
          orderDate = event.payload.orderDate;
        }
        order.orderDate = orderDate;
        if (item.isActiveOffer) {
          Offer.findOne({
            _id: item.offerId
          }, function(err, offer) {
            if (err) {
              return logger.error("Error finding offer:" + err);
            }
            if (!offer) {
              return logger.warn("No offer found : " + order);
            }
            return _.each(offer.investments, function(investment, index, list) {
              var newRev, pctOfSale, rev, revenueForSale;
              pctOfSale = (investment.sharesPurchased / offer.numShares) * (offer.pctOfferingToSell / 100);
              revenueForSale = item.price * pctOfSale;
              revenueForSale = Math.round(revenueForSale * 100) / 100;
              rev = {
                orderId: order._id,
                investorId: investment.userId,
                offeringId: offer._id,
                offeringName: offer.name,
                amount: revenueForSale,
                earnDate: orderDate
              };
              newRev = new Revenue(rev);
              return newRev.save();
            });
          });
        }
        return Wager.find({
          itemId: itemId
        }, function(err, wagers) {
          if (err) {
            logger.error("error finding wagers " + err);
          }
          if (wagers) {
            return _.each(wagers, function(wager, index, list) {
              var newPoints, points, pointsThisEvent;
              points = wager.points;
              pointsThisEvent = Math.round(price) * wager.chipCount;
              newPoints = points + pointsThisEvent;
              wager.points = newPoints;
              wager.history.push({
                eventDate: orderDate,
                points: pointsThisEvent
              });
              return wager.save(function(err) {
                if (err) {
                  logger.error("error updating wager: " + err);
                }
                return logger.info("wager updated");
              });
            });
          }
        });
      });
      return order.save(function(err) {
        var neworder;
        if (err) {
          logger.error("Error buying order: " + err);
        }
        logger.info("Order purchased");
        neworder = new Order({
          sessionId: event.payload.sessionId,
          type: 'cart',
          sessOrd: nextSessOrd
        });
        return neworder.save(function(err) {
          if (err) {
            logger.error("Error Creating Order" + err);
          }
          return logger.info("Order Created");
        });
      });
    });
  };

  exports.itemAddedToOrder = function(event) {
    logger.debug(event);
    return Artist.findOne({
      "albums._id": event.payload.itemId
    }, function(err, artist) {
      var newItem;
      if (err) {
        return logger.error("Error finding artist: " + err);
      }
      if (!artist) {
        return logger.error("Artist not found");
      }
      newItem = event.payload;
      newItem.artistId = artist._id;
      newItem.artistName = artist.artistName;
      return Order.findOneAndUpdate({
        sessionId: event.payload.sessionId
      }, {
        $push: {
          items: newItem
        }
      }, function(err, order) {
        if (err) {
          return logger.error("Error Adding Item to Order: " + err);
        }
        if (!order) {
          return logger.error("Order not found to update: " + event.payload);
        }
      });
    });
    /*
    Order.findOne {sessionId: event.payload.sessionId}, (err,order) ->
      #logger.error ""
      # enhance the item with the artist id and name
    
      Artist.findOne {"albums._id":event.payload.itemId}, (err,artist) ->
        return logger.error "Error finding artist: " + err if err
        return logger.error "Artist not found" if (!artist)
        newItem = event.payload
        newItem.artistId = artist._id
        newItem.artistName = artist.artistName
        order.items.push event.payload
        order.save (err) ->
          logger.error "Error Adding Item To Order" + err if err
          logger.debug "Added Item to Order: " + event.payload
    */

  };

  exports.orderCreated = function(event) {
    var order;
    logger.debug(event);
    order = new Order(event.payload);
    return order.save(function(err) {
      if (err) {
        logger.error("Error Creating Order" + err);
      }
      return logger.info("Order Created");
    });
  };

  exports.userAssignedToOrder = function(event) {
    logger.debug(event);
    return Order.findOneAndUpdate({
      sessionId: event.payload.sessionId
    }, {
      userId: event.userId
    }, function(err, order) {
      if (err) {
        return logger.error("Error Updating Order with user id" + err);
      }
    });
  };

  exports.orderDelete = function(event) {
    logger.debug(event);
    return Order.findOneAndRemove({
      sessionId: event.payload.sessionId
    }, function(err, order) {
      if (err) {
        return logger.error("Error Deleting Order: " + err);
      }
    });
  };

}).call(this);
